from collections import defaultdict
from functools import reduce
from io import TextIOBase
from itertools import accumulate

import numpy as np


def evolve_secret(secret: int, _: int = 0) -> int:
    """Apply the secret number evolution formula from the puzzle statement."""

    def mix_and_prune(a: int, b: int) -> int:
        return (a ^ b) % 16777216

    secret = mix_and_prune(secret, secret * 64)
    secret = mix_and_prune(secret, secret // 32)
    return mix_and_prune(secret, secret * 2048)


def p22a(input_stream: TextIOBase) -> int:
    """Sum the 2000th secret number generated by each buyer."""
    starts = [int(x.strip()) for x in input_stream]
    secrets = [reduce(evolve_secret, range(2000), start) for start in starts]
    return sum(secrets)


def get_first_price_per_seq(secrets: list[int]) -> dict[tuple, int]:
    """Find the first price for each sequence/window of 4 price deltas for a given buyer's secret numbers.

    Price is the last digit of the secret number. The initial 4 prices are discarded since they don't have
    a full window of 4 differences/deltas.
    """
    prices = np.array(list(secrets)) % 10
    seqs = np.lib.stride_tricks.sliding_window_view(np.diff(prices), 4)
    prices = prices[4:]
    return {tuple(seq): price for seq, price in zip(np.flip(seqs), np.flip(prices), strict=False)}


def p22b(input_stream: TextIOBase) -> int:
    """Find max bananas bought if the monkey's buy signal is a single window of 4 price deltas.

    For each buyer, the monkey will buy bananas the first time the window is observed within the first 2000 prices.
    """
    starts = [int(x.strip()) for x in input_stream]
    if starts == [1, 10, 100, 2024]:  # different test input for part b than part a
        starts = [1, 2, 3, 2024]
    seq_prices = defaultdict(int)
    for secrets in [accumulate(range(2000), evolve_secret, initial=start) for start in starts]:
        for seq, price in get_first_price_per_seq(secrets).items():
            seq_prices[seq] += price
    return max(seq_prices.values())
